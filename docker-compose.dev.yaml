# This file for development
services:

  #nginx

  web:
    image: nginx:latest
    ports: 
      - "81:80"
    restart: unless-stopped

    #there are two way to links your file with ocntainer or copaing your file into container and replace
    #best is docker copy but it will accurate to use it while production
    #here we map our files with container's files not copying beachuese we mainwhile we are working with our fiiles
    #so that's way we use volume to map our files wiht container's files

    volumes:
      - ./nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf

    #here /etc is used in Linix for folder that contain configraution
    #inside of it we create a folder nginx


  #php
  app:
    build:
      # when we build this file this will look inside context insdie build:
      # but here we did not mention context so it this will use folder where this dockerfile is in as context
      # that way we use      COPY ./app/composer.* ./      inside ./php/Dockerfile
      # we can't use it       COPY ../app/composer.* ./   like here means we can't use ../app configs:
      dockerfile: ./php/DockerFile 
      # multi-stage build
      # target: app_dev
      target: "${BUILD_TARGET:-app}"
      # here you can see that we use targe --app_dev-- it mean build
      # it wll build all the above build of the dockerFile up this build app_dve
      # I mean that the Docker build process includes all stages from the beginning 
      # of the Dockerfile up to and including the specified target stage. 
      # It doesn't skip or exclude any stages in between.

      # BUILD_TARGET we have difine env varailbe wiht its default value app it means every developer
      # locally can set it's value whatever he want for locally testing or developemtn purposes




      ## env environment varible 
      # becasue this service ish is responsidlbe for handling the appplication code
      # that's way  we defien here environment variables
      # thse environment variables we can use inside our application
      # if you notice there are env varilabe inside db services mysql
      # but those just for that services mean we can not use them iside our application
    environment:
      MYSQL_HOST: db
      # please note here we use db this db, because it's name of service db just like IP address
      # inside of services we can mention any service any where like db, that will find it's self without anyother extra configration

      # MYSQL_PORT: 3306
      MYSQL_PORT: ${MYSQL_PORT}
      # ${MYSQL_PORT} : here we write it like ${MYSQL_PORT} but if we write $MYSQL_PORT then this will also wokred
      # the reason behind writing like that ${MYSQL_PORT} that because if there are string so it can used as quote
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
      REDIS_HOST: cache # cache it's  name of the service, we can use it's name as it as above mentioned
      REDIS_PORT: ${REDIS_PORT}
      XDEBUG_MODE: "${XDEBUG_MODE:-off}"
      # XDEBUG_MODE:-off this mean if we dont have XDEBUG_MODE variable in envorinment then it value is off
      # this thing we can do with command line also
    extra_hosts:
      # Ensure that host.docker.internal is correctly defined on Linux
      - host.docker.internal:host-gateway
      # host.docker.internal, we have mentions it's details in xdebug.ini file
      # ther pupose of using this in this docker-compose file that
      # this will use with LINUX
      # sow if we work with linix 
      # then we have to define this extra_host here in order to this host.docker.internal to define for linix


    
    
    volumes:
      # - /var/www/html/vendor
      # we remove this in development staging
      # - ./app:/var/www/html
      #
      - ./app:/app # in production we replace this /app with this  /var/www/html
        # ./app in the hostmachine will map to our app (folder) in the root directory 
      # 
      # for X debugger
      - ./php/conf.d/xdebug.ini:/usr/local/etc/php/conf.d/xdebug.ini:ro
      # ro means read only
      # because this is not something we want to write to in our container
      # we are just just set our configration and we are happy with it




  #mysql
  db:
    image: mysql:8.0
    # image: mysql:latest
    volumes:
      # this maping is little bit differnet than last one in last we define folder but here we let docker decide 
      # to do this more sufficient way of doing it because it's not files which i acuttly want to be part of my projects
      # and not something i want to add in gitignore  
      # and so the way i am going to do this here means that i will aculally have to do that and docker will take care of handling it
      # wher i puts and it will optimize my system
      - mysqldata:/var/lib/mysql
      # /var/lib/mysql so here it's the pat in container 
    ports:
      - "3307:3306"
    restart: unless-stopped
      # restart: always
      # this quite comman for lot of contaier you want to sure that they're up and running all the time
      # always: there are option to say always but i tend not to use this in my development envioremtnet (it should be used while production)
      # becasue it sort of becomes like a Hydra i can nver kill the container 
      # so for developemetn the best is use unless-stopped
      # so if anything goes wrong it will resarte to stop this we use unless-stopped means not stop unless we not stopped it physically
    
    # next we need to pass some information to mySQL such as the user,password, db for that we use environment variables
    environment:
    # you can docker hub there they here search for mysql and in mysql image they define varibel name only those we can use it there
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_ROOT_PASSWORD:  ${MYSQL_PASSWORD}
      # MYSQL_HOST: 127.0.0.1
      # MYSQL_PORT: 3306
      # MYSQL_USER: root2
      # MYSQL_PASSWORD: root2
      # MYSQL_ALLOW_EMPTY_PASSWORD:


  #redis
  cache:
    image: redis:latest
    


  

# after that we need to create a volume key at same level at we have services key

volumes:
  mysqldata:
  # if we just leave it as it  
  # mysqldata: 
  # then docker will figure out best way and best place to put this data but 
  # the most imporant thing for us to know about this is that our data will be preserved in between eachtime that
  # we spin up Docker compose 


 







